"""SQLAlchemy models for Reddit Analyzer."""

from sqlalchemy import (
    Column, Integer, String, Text, TIMESTAMP,
    Enum, DECIMAL, JSON, BigInteger, ForeignKey, UniqueConstraint
)
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from .connection import Base


class RedditPost(Base):
    """
    Metadata for posts from multiple sources (Reddit, HackerNews, etc).
    Table renamed to 'posts' for multi-source support.
    """
    __tablename__ = 'posts'

    id = Column(String(50), primary_key=True, comment='Prefixed post ID (reddit_abc123, hn_8863)')
    source = Column(
        Enum('reddit', 'hackernews', name='source_enum'),
        nullable=False,
        index=True,
        comment='Content source'
    )
    project = Column(
        String(50),
        nullable=False,
        default='default',
        index=True,
        comment='Project identifier (e.g., "claudeia", "wineworld")'
    )
    subreddit = Column(String(100), nullable=True, index=True, comment='Reddit: subreddit name, HN: null')
    title = Column(Text, nullable=False)
    author = Column(String(100))
    score = Column(Integer)
    num_comments = Column(Integer)
    created_utc = Column(BigInteger, index=True, comment='Unix timestamp')
    url = Column(Text)
    selftext = Column(Text, comment='Truncated to 5000 chars/MAX_LINES_ARTICLE')
    fetched_at = Column(TIMESTAMP, server_default=func.now())

    # Relationship
    classification = relationship(
        "Classification",
        back_populates="post",
        uselist=False,  # One-to-one
        cascade="all, delete-orphan"
    )

    def to_dict(self):
        """Convert model to dict."""
        return {
            'id': self.id,
            'subreddit': self.subreddit,
            'title': self.title,
            'author': self.author,
            'score': self.score,
            'num_comments': self.num_comments,
            'created_utc': self.created_utc,
            'url': self.url,
            'selftext': self.selftext
        }


class Classification(Base):
    """
    Classifications generated by Claude.
    One classification per (post_id, project) - UNIQUE KEY (post_id, project).
    """
    __tablename__ = 'classifications'

    id = Column(Integer, primary_key=True, autoincrement=True)
    post_id = Column(
        String(50),
        ForeignKey('posts.id', ondelete='CASCADE'),
        nullable=False
    )
    source = Column(
        Enum('reddit', 'hackernews', name='source_enum'),
        nullable=False,
        index=True,
        comment='Content source matching the post'
    )
    project = Column(
        String(50),
        nullable=False,
        default='default',
        index=True,
        comment='Project identifier (matches post.project)'
    )
    category = Column(
        Enum(
            'technical', 'troubleshooting', 'research_verified',
            'mystical', 'unverified_claim', 'engagement_bait',
            'community', 'meme', 'outlier',
            'unrelated',  # Posts outside topic scope
            name='category_enum'
        ),
        nullable=False,
        index=True
    )
    confidence = Column(DECIMAL(3, 2), comment='0.00-1.00')
    red_flags = Column(JSON, comment='Array of red flags')
    reasoning = Column(Text)
    model_version = Column(String(50), default='claude-haiku-4-5-20251001')
    classified_at = Column(TIMESTAMP, server_default=func.now(), index=True)
    sent_in_digest_at = Column(
        TIMESTAMP,
        nullable=True,
        comment='When this post was included in a daily digest email'
    )

    # UNIQUE constraint on (post_id, project)
    __table_args__ = (
        UniqueConstraint('post_id', 'project', name='unique_post_project'),
    )

    # Relationship
    post = relationship("RedditPost", back_populates="classification")

    def to_dict(self):
        """Convert model to dict."""
        return {
            'post_id': self.post_id,
            'category': self.category,
            'confidence': float(self.confidence) if self.confidence else None,
            'red_flags': self.red_flags or [],
            'reasoning': self.reasoning,
            'model_version': self.model_version
        }


class ScanHistory(Base):
    """
    Scan history for tracking and analytics (multi-source support).
    """
    __tablename__ = 'scan_history'

    id = Column(Integer, primary_key=True, autoincrement=True)
    subreddit = Column(String(100), nullable=True, index=True, comment='Subreddit name (reddit) or "HackerNews" (HN)')
    source = Column(
        Enum('reddit', 'hackernews', name='source_enum'),
        nullable=True,
        index=True,
        comment='Content source for this scan'
    )
    project = Column(
        String(50),
        nullable=False,
        default='default',
        index=True,
        comment='Project identifier for this scan'
    )
    scan_date = Column(TIMESTAMP, server_default=func.now(), index=True)
    posts_fetched = Column(Integer, comment='Total posts from Reddit')
    posts_classified = Column(Integer, comment='New posts classified')
    posts_cached = Column(Integer, comment='Posts from cache')
    signal_ratio = Column(DECIMAL(5, 2), comment='Signal percentage')

    def to_dict(self):
        """Convert model to dict."""
        return {
            'subreddit': self.subreddit,
            'scan_date': self.scan_date,
            'posts_fetched': self.posts_fetched,
            'posts_classified': self.posts_classified,
            'posts_cached': self.posts_cached,
            'signal_ratio': float(self.signal_ratio) if self.signal_ratio else None
        }
